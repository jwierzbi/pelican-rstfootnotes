"""RstFootnotes Pelican plugin.

The plugin looks up footnotes generated by Docutils and replaces them with
either a bullet list or definition list (depending on settings).

Docutils generates footnotes as a series of tables which doesn't look good
in HTML (e.g. since there are multiple tables, the width of the columns between
tables may differ)."""

from itertools import chain
import re
from typing import List
from xml.dom.minidom import Document, Element

import html5lib

from pelican import signals
from pelican.settings import DEFAULT_CONFIG

from .settings import RST_FOOTNOTES_TYPE


def _init(pelican):
    """Handles Pelican's "initialize" signal.

    Args:
        pelican: Pelican instance.
    """
    DEFAULT_CONFIG.setdefault("RST_FOOTNOTES_TYPE", RST_FOOTNOTES_TYPE)
    if pelican is not None:
        pelican.settings.setdefault("RST_FOOTNOTES_TYPE", RST_FOOTNOTES_TYPE)


def _prev_non_text_node(node: Element) -> Element:
    """Find preceding non-text node.

    Args:
        node (Element): Current node.

    Returns:
        Element: First non-text sibling preceding the `node`.
    """

    prev = node.previousSibling
    while prev is not None and prev.nodeType == prev.TEXT_NODE:
        prev = prev.previousSibling

    return prev


def _build_footnotes_list(document: Document) -> List[List[Element]]:
    """Build lists of tables for the footnotes.

    Footnotes are grouped in the document as a series of tables. Each series can be
    "squashed" into a single list of footnotes.

    The functions goes though all of the tables in the document and checks if the table
    has a 'footnote' class. If it is it then groups all of the neighbouring tables in
    one list and then returns a list of those lists. This makes it easy to further
    process the footnotes.

    Args:
        document (Document): Input document that the footnotes are going to be
                             extracted from.

    Returns:
        list: List of lists of footnotes.
    """

    series = []
    prev_footnote, this_footnote = None, None
    for table in document.getElementsByTagName("table"):
        cls = table.attributes.get("class")
        if cls is not None and "footnote" in cls.value:
            # this is a footnote table so find the previous first non-text
            # element to check if this is a nth footnote in a series
            prev_non_text = _prev_non_text_node(table)
            if prev_non_text is not None and prev_non_text.isSameNode(prev_footnote):
                # the first non-text element is the same as recorder previous
                # element (which must be a footnote table) so we found
                # neighbouring table that we can squash
                this_footnote.append(table)
            else:
                # this is a first footnote in a series because the previous
                # non-text element is not a footnote table
                this_footnote = [table]
                # insert at head, will make further processing easier
                series.insert(0, this_footnote)
            prev_footnote = table

    return series


def _generate_definition_list(document: Document, footnotes: List[Element]) -> Element:
    """Create new definition list node from footnotes tables.

    The function goes through the list of footnotes tables and copies the data to a
    newly created definition list.

    Args:
        document (Document): Input document.
        footnotes (list): List of footnotes tables.

    Returns:
        Element: Definition list node.
    """

    # create new definition list node
    footnotes_node = document.createElement("dl")
    footnotes_node.setAttribute("class", "footnotes")

    for footnote in footnotes:
        cells = footnote.getElementsByTagName("td")

        # for every footnote create new list entry

        # copy over the footnote id
        footnote_node_number = document.createElement("dt")
        footnote_node_number.setAttribute("class", footnote.attributes["class"].value)
        footnote_node_number.setAttribute("id", footnote.attributes["id"].value)
        footnote_node_number.childNodes = cells[0].childNodes

        # and footnote content
        footnote_node_content = document.createElement("dd")
        footnote_node_content.childNodes = cells[1].childNodes

        # fill in the list entry
        footnotes_node.appendChild(footnote_node_number)
        footnotes_node.appendChild(footnote_node_content)

    return footnotes_node


def _generate_bullet_list(document: Document, footnotes: List[Element]) -> Element:
    """Create new bullet list node from footnotes tables.

    The function goes through the list of footnotes tables and copies the data to a
    newly created bullet list.

    Args:
        document (Document): Input document.
        footnotes (list): List of footnotes tables.

    Returns:
        Element: Bullet list node.
    """

    # create new bullet list node
    footnotes_node = document.createElement("ul")
    footnotes_node.setAttribute("class", "footnotes")

    for footnote in footnotes:
        cells = footnote.getElementsByTagName("td")

        # for every footnote create new list entry
        footnote_node_element = document.createElement("li")

        # copy over the footnote id
        footnote_node_number = document.createElement("span")
        footnote_node_number.setAttribute("class", footnote.attributes["class"].value)
        footnote_node_number.setAttribute("id", footnote.attributes["id"].value)
        footnote_node_number.childNodes = cells[0].childNodes

        # and footnote content
        footnote_node_content = document.createElement("span")
        footnote_node_content.childNodes = cells[1].childNodes

        # fill in the list entry
        footnote_node_element.appendChild(footnote_node_number)
        footnote_node_element.appendChild(footnote_node_content)
        footnotes_node.appendChild(footnote_node_element)

    return footnotes_node


def _replace_footnotes(
    content: str, old_nodes: List[List[Element]], new_nodes: List[Element]
) -> str:
    """Replace footnotes tables (`old_nodes`) with newly crated representation of the
    footnotes (`new_nodes`).

    Args:
        content (str): Content of the document (HTML).
        old_nodes (list): Footnotes tables that are going to be replaced.
        new_nodes (list): Footnotes list that is going to replace old tables.

    Returns:
        str: New content of the document (HTML).
    """

    # process in reverse order
    for old_footnote, new_footnote in zip(old_nodes, new_nodes):
        start, end = None, None

        # find the starting index of the footnote table series
        m = re.search(
            rf'<table[^>]*id="{old_footnote[0].attributes["id"].value}".+?\/table>',
            content,
            re.DOTALL,
        )
        start = m.start()

        # find the ending index of the footnote table series
        m = re.search(
            rf'<table[^>]*id="{old_footnote[-1].attributes["id"].value}".+?\/table>',
            content,
            re.DOTALL,
        )
        end = m.end()

        content = (
            content[:start]
            + new_footnote.toprettyxml(indent="    ")
            + content[end + 1 :]
        )

    return content


def _process_footnotes(content: str, format: str) -> str:
    """Find all footnotes tables generated by Docutils and replace them with a new
    selected representation (e.g. bullet list).

    Args:
        content (str): Content of the document (HTML).
        format (str): New format of the footnotes.

    Returns:
        str: New content of the document (HTML).
    """

    parser = html5lib.HTMLParser(tree=html5lib.getTreeBuilder("dom"))
    document = parser.parse(content)

    # build lists of tables for the footnotes
    # there can be multiple lists where each lists contains neighbouring footnote
    # tables so they can be easily "squashed" into one list

    series = _build_footnotes_list(document)

    # build new representation of the footnotes

    new_nodes = []
    if format == "DEFINITION_LIST":
        for footnotes in series:
            new_nodes.append(_generate_definition_list(document, footnotes))
    elif format == "BULLET_LIST":
        for footnotes in series:
            new_nodes.append(_generate_bullet_list(document, footnotes))
    else:
        raise RuntimeError("Invalid value for RST_FOOTNOTES_TYPE")

    # replace the tables with newly created nodes and return new content

    return _replace_footnotes(content, series, new_nodes)


def _process_articles_footnotes(article_generator):
    """Handles Pelican's "article_generator_finalized" signal.

    Args:
        article_generator: Article generator.
    """
    for article in chain(article_generator.articles, article_generator.drafts):
        article._content = _process_footnotes(
            article._content, article_generator.settings["RST_FOOTNOTES_TYPE"]
        )


def _process_pages_footnotes(page_generator):
    """Handles Pelican's "page_generator_finalized" signal.

    Args:
        page_generator: Page generator.
    """
    for page in page_generator.pages:
        page._content = _process_footnotes(
            page._content, page_generator.settings["RST_FOOTNOTES_TYPE"]
        )


def register():
    signals.initialized.connect(_init)
    signals.article_generator_finalized.connect(_process_articles_footnotes)
    signals.page_generator_finalized.connect(_process_pages_footnotes)
